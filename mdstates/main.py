import mdtraj as md
import numpy as np

from .data import bonds
from .hmm import viterbi


class Network:
    """
    Analyze different states and transitions of an MD trajectory.

    Attributes
    ----------
    replica : dict
        Container for each trajectory and it's associated contact
        matrix. All trajectories must have matching topologies.
    atoms : list
        List of atoms for in topologoy.
    n_atoms : int
        Number of atoms in topology.
    pbc : bool
        Periodic boundary condition.
    frames : tuple
        Frames at which an transition is recorded.
    """

    def __init__(self):
        self.replica = []
        self.atoms = None
        self.n_atoms = None
        self.pbc = True
        self.frames = ()

        self._pairs = []
        self._cutoff = {}
        return

    def addreplica(self, trajectory, topology, **kwargs):
        """
        Loads a trajectory into the class.

        Parmeters
        ---------
        trajectory : str
            File name of the trajectory file.
        topology : str
            File name of the topology file.
        traj_id : int
            ID of the loaded trajectory.
        """

#        if not self.replica:
#            rep_id = 0
#            self.replica[rep_id] = {'traj': None, 'cmat': None}
#        else:
#            rep_id = max(list(self.replica.keys())) + 1
#            self.replica[rep_id] = {'traj': None, 'cmat': None}

        self.replica.append({'traj': None, 'cmat': None})

        self.replica[-1]['traj'] = md.load(trajectory, top=topology,
                                               **kwargs)

        # Set the number of atoms.
        if self.n_atoms is None:
            self.n_atoms = self.replica[0]['traj'].n_atoms
        else:
            pass

        # Generate the atom list.
        if self.atoms is None:
            self._get_atoms()
        else:
            pass

        return

    def removereplica(self, rep_id):
        """
        Removes a replica that was added previously.

        Parameters
        ----------
        rep_id : int

        Raises
        ------
        KeyError
            If `rep_id` does not match any replicas presently loaded.
        """

        # if rep_id not in self.replica.keys():
        if rep_id < len(self.replica) - 1:
            raise IndexError(str(rep_id) + ' is outside of the index range.')
        else:
            pass

        del self.replica[rep_id]
        return

    def generate_contact_matrix(self):
        """
        Converts each trajectory to a series of contact matrices.

        The unique atom pairs are first generated if they have not been
        generated previously. Next, the cutoff dictionary for all the
        unique atom pairs is built. Lastly, for each replica that does
        not already have a contact matrix, it is generated by computing
        the interatomic distances for all pairs generated previously,
        reshapes the array into contact matrices for each frame, then
        converts the interatomic distances to a `1` or `0`, depending
        on the atom pair's cutoff.
        """

        # Check if atom pairs have been determined.
        if not self._pairs:
            self._generate_pairs()
        else:
            pass

        # Check if cutoff matrix has been built.
        if len(self._cutoff) < len(self._pairs):
            self._build_cutoff()
        else:
            pass

        for i, rep in enumerate(self.replica):
            if rep['cmat'] is None:
                distances = self._compute_distances(i)
                distances = self._reshape_to_square(distances)
                rep['cmat'] = self._build_connections(distances)
            else:
                pass

        return

    def _generate_pairs(self):
        """
        Generates the atom pairs for interatomic distance calculations.
        """
        for i in range(self.n_atoms-1):
            for j in range(i+1, self.n_atoms):
                self._pairs.append([i, j])
        return

    def _compute_distances(self, rep_id):
        """
        Computes the interatomic distances for all pairs of atoms.

        Parameters
        ----------
        rep_id : int
            ID number of the replica of interest.

        Returns
        -------
        numpy.ndarray
            Interatomic distances for all specified atom pairs. Shape
            is (n_frames, n_pairs).

        Raises
        ------
        IndexError
            If `rep_id` is not an index in `replica`.
        AssertionError
            If the trajectory associated with `rep_id` does not exist.
        AssertionError
            If the atom pairs have not been determined.
        """
        if rep_id < len(self.replica) - 1:
            raise IndexError(str(rep_id) + " is outside of index range.")
        assert self.replica[rep_id]['traj'],\
            "Trajectory does not exist."
        assert self._pairs, "Atom pairs not determined yet."

        return md.compute_distances(self.replica[rep_id]['traj'],
                                    self._pairs, periodic=self.pbc)

    def _reshape_to_square(self, linear_matrix):
        """
        Converts a row matrix into a square matrix.

        Takes each row and reshapes it to fit into the upper triangle
        of a square matrix, i.e. populating the upper off-diagonal
        elements.

        Parameters
        ----------
        linear_matrix : numpy.ndarray
            Row of interatomic distances at every frame. Shape is
            (n_frames, n_pairs).

        Returns
        -------
        square_matrix : numpy.ndarray
            Reshaped matrix to be 3D. Each row is reshaped into a square
            matrix with only the upper off-diagonal elements populated
            for all frames.

        Example
        -------
            >>> foo = np.array([[1, 2, 3],
                                [4, 5, 6]])

            >>> bar = self._reshape_to_square(foo)

            >>> bar[0, :, :]
            array([[0, 1, 2],
                   [0, 0, 3],
                   [0, 0, 0]])

            >>> bar[1, :, :]
            array([[0, 4, 5],
                   [0, 0, 6],
                   [0, 0, 0]])
        """
        frames = linear_matrix.shape[0]
        square_matrix = np.zeros((frames, self.n_atoms, self.n_atoms))
        upper_tri_id = np.triu_indices(self.n_atoms, 1)

        for f in range(frames):
            square_matrix[f, upper_tri_id[0], upper_tri_id[1]] =\
                linear_matrix[f, :]

        return square_matrix

    def _build_connections(self, distances):
        """
        Converts an array of distances to a contact matrix.

        Parameters
        ----------
        distances : numpy.ndarray
            Interatomic distances at all frames for all unique atom
            pairs.

        Returns
        -------
        cmat : numpy.ndarray
            Contact matrix at all frames
        """
        frames = distances.shape[0]

        cmat = np.zeros((frames, self.n_atoms, self.n_atoms), dtype=int)

        for i in range(self.n_atoms-1):
            for j in range(i+1, self.n_atoms):
                atom1 = self.atoms[i]
                atom2 = self.atoms[j]
                cmat[:, i, j] =\
                    np.where(distances[:, i, j] <
                             self._cutoff[frozenset([atom1, atom2])], 1, 0)
        return cmat

    def _get_atoms(self):
        """Generates the list of atoms in the trajectory."""

        table, bonds = self.replica[0]['traj'].top.to_dataframe()
        self.atoms = table['element'].tolist()
        return

    def _build_cutoff(self):
        """
        Builds the cutoff dictionary for all unique atom pairs.

        Finds the unique atoms in the system, then loops over
        every unique pair of atoms and checks the bond distance
        database for a value.

        Raises
        ------
        AssertionError
            If the atom list is not compiled.
        """

        assert self.atoms, "Atom list is not yet compiled"

        atoms = self.atoms
        unique = []
        for atom in atoms:
            if atom not in unique:
                unique.append(atom)

        for i, atom1 in enumerate(unique):
            for atom2 in unique[i:]:
                if frozenset([atom1, atom2]) not in self._cutoff.keys():
                    self._cutoff[frozenset([atom1, atom2])] =\
                        self._bond_distance(atom1, atom2)
        return

    def _bond_distance(self, atom1, atom2):
        """
        Queries a database to fetch a bond distance between two atoms.

        Parameters
        ----------
        atom1 : str
        atom2 : str

        Returns
        -------
        float
            Equilibrium bond distance for the 2 atoms that were passed.

        Raises
        ------
        LookupError
            If the atom pair is not present in the database.
        """
        pair = []
        pair.append(str(atom1)+'-'+str(atom2))
        pair.append(str(atom2)+'-'+str(atom1))
        loc_bool = [x in bonds.index for x in pair]
        if any(loc_bool):
            idx = loc_bool.index(True)
            return float(bonds.loc[pair[idx], 'distance']) * 0.10 + 0.02
        else:
            raise LookupError(pair[0] + " was not found in cutoff " +
                              "database. Please manually add it to " +
                              "the cutoff dictionary using " +
                              "Network.set_cutoff() and then rerun " +
                              "Network.generate_contact_matrix().")

    def set_cutoff(self, atoms, cutoff):
        """Assigns the cutoff for a pair of atoms."""
        self._cutoff[frozenset(atoms)] = cutoff
        return
